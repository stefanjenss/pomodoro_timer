<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pomodoro Timer — Unit Tests</title>
    <style>
        body { font-family: "Avenir Next", "Segoe UI", monospace; padding: 20px; background: #fafbfc; color: #1f2933; }
        h1 { margin-top: 0; }
        .pass { color: #2f855a; }
        .fail { color: #c44536; font-weight: bold; }
        .summary { margin-top: 20px; font-size: 1.2em; font-weight: bold; padding: 12px; border-radius: 8px; }
        .summary.all-pass { background: #e6ffed; color: #2f855a; }
        .summary.has-fail { background: #ffeef0; color: #c44536; }
        .group { margin-top: 16px; font-weight: bold; font-size: 1.05em; color: #334e68; }
    </style>
</head>
<body>
    <h1>Pomodoro Timer — Unit Tests</h1>
    <div id="results"></div>

    <!-- Test harness flag must be set BEFORE loading pomodoro.js -->
    <script>window.__POMODORO_TEST_HARNESS__ = true;</script>

    <!-- Minimal DOM stubs (hidden) so the ui object initializes -->
    <main class="app" style="display:none;">
        <link id="favicon" rel="icon">
        <div id="timerShell" class="timer-shell phase-work">
            <p id="phaseLabel"></p>
            <p id="timeDisplay"></p>
            <p id="phaseNote"></p>
            <div class="progress-track"><div id="progressFill" class="progress-fill"></div></div>
            <span id="liveAnnounce"></span>
        </div>
        <button id="startPauseBtn"></button>
        <button id="resetBtn"></button>
        <button id="switchPhaseBtn"></button>
        <button id="enableNotifyBtn"></button>
        <p id="workCount"></p>
        <p id="breakCount"></p>
        <span id="notifyStatus"></span>
        <button class="preset-btn" data-preset="25_5">25/5</button>
        <button class="preset-btn" data-preset="50_10">50/10</button>
        <button class="preset-btn" data-preset="custom">Custom</button>
        <button id="darkModeBtn"></button>
        <div id="customPresetUI">
            <input id="customWorkMin" type="number" value="25">
            <input id="customBreakMin" type="number" value="5">
            <button id="applyCustomBtn"></button>
        </div>
        <select id="soundSelect"><option value="beep">Beep</option><option value="gentle">Gentle</option><option value="none">None</option></select>
        <input id="volumeSlider" type="range" value="50">
        <span id="volumeDisplay"></span>
        <button id="previewSoundBtn"></button>
        <input id="longBreakInterval" type="number" value="4">
        <input id="longBreakDuration" type="number" value="15">
        <input id="autoStartNextPhase" type="checkbox">
        <input id="allowFlowState" type="checkbox">
        <div id="todaySummary"></div>
        <div id="weeklySummary"></div>
        <div id="analyticsHeatmap"></div>
        <div id="analyticsTrend"></div>
        <div id="analyticsCadence"></div>
        <button id="exportBtn"></button>
        <button id="importBtn"></button>
        <input id="importFile" type="file">
    </main>

    <!-- Load the app (test export will populate window.__pomodoro) -->
    <script src="pomodoro.js"></script>

    <script>
        // --- Minimal test framework ---
        var results = document.getElementById("results");
        var passed = 0;
        var failed = 0;

        function group(name) {
            results.innerHTML += '<p class="group">' + name + "</p>";
        }

        function assert(condition, message) {
            if (condition) {
                passed++;
                results.innerHTML += '<p class="pass">&#10003; ' + message + "</p>";
            } else {
                failed++;
                results.innerHTML += '<p class="fail">&#10007; ' + message + "</p>";
            }
        }

        function assertEqual(actual, expected, message) {
            var pass = actual === expected;
            if (pass) {
                passed++;
                results.innerHTML += '<p class="pass">&#10003; ' + message + "</p>";
            } else {
                failed++;
                results.innerHTML += '<p class="fail">&#10007; ' + message + " (expected: " + JSON.stringify(expected) + ", got: " + JSON.stringify(actual) + ")</p>";
            }
        }

        // --- Get exposed internals ---
        var app = window.__pomodoro;
        if (!app) {
            results.innerHTML = '<p class="fail">FATAL: window.__pomodoro not available. Test harness failed to load.</p>';
        } else {

            // ========================
            // formatTime
            // ========================
            group("formatTime");
            assertEqual(app.formatTime(0), "00:00", "formatTime(0)");
            assertEqual(app.formatTime(61), "01:01", "formatTime(61)");
            assertEqual(app.formatTime(1500), "25:00", "formatTime(1500)");
            assertEqual(app.formatTime(3599), "59:59", "formatTime(3599)");
            assertEqual(app.formatTime(-5), "00:00", "formatTime(-5) clamps to 00:00");
            assertEqual(app.formatTime(3600), "60:00", "formatTime(3600)");

            // ========================
            // parseJson
            // ========================
            group("parseJson");
            assertEqual(app.parseJson(null, "default"), "default", "parseJson null returns fallback");
            assertEqual(app.parseJson("", "fb"), "fb", "parseJson empty string returns fallback");
            assertEqual(app.parseJson("invalid json!", "fb"), "fb", "parseJson invalid returns fallback");
            assertEqual(app.parseJson('{"a":1}', null).a, 1, "parseJson valid JSON parses correctly");
            assertEqual(app.parseJson("42", null), 42, "parseJson number string");

            // ========================
            // safeGetItem / safeSetItem
            // ========================
            group("safeGetItem / safeSetItem");
            var testKey = "pomodoro.test.key";
            assert(app.safeSetItem(testKey, "hello") === true, "safeSetItem returns true on success");
            assertEqual(app.safeGetItem(testKey), "hello", "safeGetItem retrieves stored value");
            try { localStorage.removeItem(testKey); } catch(e) {}

            // ========================
            // getPhaseDuration
            // ========================
            group("getPhaseDuration");
            app.state.workDurationSeconds = 1500;
            app.state.breakDurationSeconds = 300;
            app.state.isLongBreak = false;
            assertEqual(app.getPhaseDuration("work"), 1500, "getPhaseDuration work = 1500");
            assertEqual(app.getPhaseDuration("break"), 300, "getPhaseDuration break = 300");

            app.state.isLongBreak = true;
            app.state.longBreakDurationSeconds = 900;
            assertEqual(app.getPhaseDuration("break"), 900, "getPhaseDuration long break = 900");
            assertEqual(app.getPhaseDuration("work"), 1500, "getPhaseDuration work unaffected by isLongBreak");
            app.state.isLongBreak = false;

            // ========================
            // PRESETS
            // ========================
            group("PRESETS");
            assertEqual(app.PRESETS["25_5"].work, 1500, "PRESETS 25_5 work = 1500");
            assertEqual(app.PRESETS["25_5"].break, 300, "PRESETS 25_5 break = 300");
            assertEqual(app.PRESETS["50_10"].work, 3000, "PRESETS 50_10 work = 3000");
            assertEqual(app.PRESETS["50_10"].break, 600, "PRESETS 50_10 break = 600");
            assert(app.PRESETS["custom"] !== undefined, "PRESETS custom exists");

            // ========================
            // switchPhase
            // ========================
            group("switchPhase");
            app.state.phase = "work";
            app.state.isRunning = false;
            app.state.workDurationSeconds = 1500;
            app.state.breakDurationSeconds = 300;
            app.switchPhase();
            assertEqual(app.state.phase, "break", "switchPhase work -> break");
            assertEqual(app.state.remainingSeconds, 300, "switchPhase sets correct break duration");
            app.switchPhase();
            assertEqual(app.state.phase, "work", "switchPhase break -> work");
            assertEqual(app.state.remainingSeconds, 1500, "switchPhase sets correct work duration");

            // ========================
            // applyPreset
            // ========================
            group("applyPreset");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            assertEqual(app.state.workDurationSeconds, 1500, "applyPreset 25_5 work = 1500");
            assertEqual(app.state.breakDurationSeconds, 300, "applyPreset 25_5 break = 300");
            assertEqual(app.state.phase, "work", "applyPreset resets to work phase");
            assertEqual(app.state.remainingSeconds, 1500, "applyPreset sets remaining to work duration");

            app.applyPreset("50_10", {resetPhase: true, persist: false});
            assertEqual(app.state.workDurationSeconds, 3000, "applyPreset 50_10 work = 3000");
            assertEqual(app.state.breakDurationSeconds, 600, "applyPreset 50_10 break = 600");

            // Reset for following tests
            app.applyPreset("25_5", {resetPhase: true, persist: false});


            group("Auto-start setting persistence");
            localStorage.setItem("pomodoro.v1.autoStartNextPhase", JSON.stringify(true));
            app.loadState();
            assertEqual(app.state.autoStartNextPhase, true, "loadState restores auto-start setting");
            var autoStartToggle = document.getElementById("autoStartNextPhase");
            assertEqual(autoStartToggle.checked, true, "auto-start toggle reflects loaded setting");

            group("Allow flow state setting persistence");
            localStorage.setItem("pomodoro.v1.allowFlowState", JSON.stringify(true));
            app.loadState();
            assertEqual(app.state.allowFlowState, true, "loadState restores allow-flow-state setting");
            var allowFlowToggle = document.getElementById("allowFlowState");
            assertEqual(allowFlowToggle.checked, true, "allow-flow-state toggle reflects loaded setting");

            // ========================
            // tick
            // ========================
            group("tick");
            app.state.isRunning = true;
            app.state.remainingSeconds = 100;
            app.state.phase = "work";
            app.state.lastTickEpochMs = Date.now() - 2000; // 2 seconds ago
            app.tick();
            assert(app.state.remainingSeconds <= 98, "tick decrements by elapsed seconds");
            assert(app.state.remainingSeconds >= 96, "tick doesn't over-decrement");
            app.stopTimer();

            // Tick with no elapsed time should not decrement
            app.state.isRunning = true;
            app.state.remainingSeconds = 50;
            app.state.lastTickEpochMs = Date.now(); // just now
            app.tick();
            assertEqual(app.state.remainingSeconds, 50, "tick with 0 elapsed does not decrement");
            app.stopTimer();

            // ========================
            // Flow state overflow
            // ========================
            group("Flow state overflow");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.stopTimer();
            app.state.allowFlowState = true;
            app.state.workCompleted = 0;
            app.state.breakCompleted = 0;
            app.state.consecutiveWorkSessions = 0;
            app.state.longBreakInterval = 4;
            app.state.phase = "work";
            app.state.remainingSeconds = 1;
            app.state.inOverflow = false;
            app.state.overflowSeconds = 0;
            app.state.pendingBreakCreditSeconds = 0;
            app.state.currentSessionStart = "2026-02-18T09:00:00.000Z";
            app.state.isRunning = true;
            var realNow = Date.now;
            Date.now = function () { return 2000; };
            app.state.lastTickEpochMs = 0;
            app.tick();
            Date.now = realNow;
            assertEqual(app.state.inOverflow, true, "work timer enters overflow at 00:00 when setting enabled");
            assertEqual(app.state.remainingSeconds, 0, "overflow keeps remaining at 0");
            assertEqual(app.state.overflowSeconds, 1, "overflow starts counting up with exact overrun");

            // Accumulate additional overflow and verify break-credit ratio (25/5 => 1:5)
            app.state.isRunning = true;
            realNow = Date.now;
            Date.now = function () { return 302000; };
            app.state.lastTickEpochMs = 2000;
            app.tick();
            Date.now = realNow;
            assertEqual(app.state.overflowSeconds, 301, "overflow increments while running");
            assertEqual(app.state.pendingBreakCreditSeconds, 60, "overflow credit follows 25/5 ratio");

            app.switchPhase();
            assertEqual(app.state.phase, "break", "switchPhase exits overflow into break");
            assertEqual(app.state.isRunning, true, "switchPhase from overflow auto-starts break");
            assertEqual(app.state.remainingSeconds, 360, "break receives proportional overflow credit");
            assertEqual(app.state.workCompleted, 1, "overflowed work still counts as one completed work session");
            assertEqual(app.state.inOverflow, false, "overflow state clears after switch");
            var overflowWorkRecord = app.state.sessionHistory[app.state.sessionHistory.length - 1];
            assertEqual(overflowWorkRecord.phase, "work", "overflow transition records completed work session");
            assertEqual(overflowWorkRecord.durationSeconds, 1801, "work duration includes overflow time");
            assertEqual(overflowWorkRecord.overflowSeconds, 301, "work history records overflow seconds");
            app.stopTimer();

            // 50/10 preset ratio should remain 1:5 for break-credit math
            app.applyPreset("50_10", {resetPhase: true, persist: false});
            app.stopTimer();
            app.state.allowFlowState = true;
            app.state.phase = "work";
            app.state.remainingSeconds = 1;
            app.state.inOverflow = false;
            app.state.overflowSeconds = 0;
            app.state.pendingBreakCreditSeconds = 0;
            app.state.isRunning = true;
            realNow = Date.now;
            Date.now = function () { return 301000; };
            app.state.lastTickEpochMs = 0;
            app.tick();
            Date.now = realNow;
            assertEqual(app.state.pendingBreakCreditSeconds, 60, "overflow credit follows 50/10 ratio");
            app.stopTimer();

            // Custom ratio should use configured work/break durations
            app.PRESETS.custom.work = 45 * 60;
            app.PRESETS.custom.break = 7 * 60;
            app.PRESETS.custom.label = "45 / 7";
            app.applyPreset("custom", {resetPhase: true, persist: false});
            app.stopTimer();
            app.state.allowFlowState = true;
            app.state.phase = "work";
            app.state.remainingSeconds = 1;
            app.state.inOverflow = false;
            app.state.overflowSeconds = 0;
            app.state.pendingBreakCreditSeconds = 0;
            app.state.isRunning = true;
            realNow = Date.now;
            Date.now = function () { return 301000; };
            app.state.lastTickEpochMs = 0;
            app.tick();
            Date.now = realNow;
            assertEqual(app.state.pendingBreakCreditSeconds, 46, "overflow credit uses custom ratio with floor rounding");
            app.stopTimer();

            // Break phase should never overflow
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.stopTimer();
            app.state.allowFlowState = true;
            app.state.phase = "break";
            app.state.isLongBreak = false;
            app.state.remainingSeconds = 1;
            app.state.inOverflow = false;
            app.state.isRunning = true;
            realNow = Date.now;
            Date.now = function () { return 4000; };
            app.state.lastTickEpochMs = 0;
            app.tick();
            Date.now = realNow;
            assertEqual(app.state.inOverflow, false, "break completion does not enter overflow");
            assertEqual(app.state.phase, "work", "break completion still transitions to work");
            app.stopTimer();

            // ========================
            // completePhase
            // ========================
            group("completePhase");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.state.workCompleted = 0;
            app.state.breakCompleted = 0;
            app.state.consecutiveWorkSessions = 0;
            app.state.longBreakInterval = 4;
            app.state.longBreakDurationSeconds = 900;
            app.state.sessionHistory = [];
            app.state.phase = "work";
            app.state.isRunning = false;
            app.state.remainingSeconds = 0;

            app.completePhase();
            assertEqual(app.state.workCompleted, 1, "completePhase increments workCompleted");
            assertEqual(app.state.phase, "break", "completePhase switches to break");
            assertEqual(app.state.consecutiveWorkSessions, 1, "completePhase increments consecutive count");
            assert(app.state.sessionHistory.length >= 1, "completePhase records session history");
            assertEqual(app.state.sessionHistory[app.state.sessionHistory.length - 1].phase, "work", "session record has correct phase");

            // Complete break
            app.state.remainingSeconds = 0;
            app.completePhase();
            assertEqual(app.state.breakCompleted, 1, "completePhase increments breakCompleted");
            assertEqual(app.state.phase, "work", "completePhase switches back to work");

            // ========================
            // Long break trigger
            // ========================
            group("Long break trigger");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.state.workCompleted = 0;
            app.state.breakCompleted = 0;
            app.state.consecutiveWorkSessions = 0;
            app.state.longBreakInterval = 3;
            app.state.longBreakDurationSeconds = 900;
            app.state.sessionHistory = [];

            // Complete 3 work sessions to trigger long break
            for (var i = 0; i < 3; i++) {
                app.state.phase = "work";
                app.state.remainingSeconds = 0;
                app.completePhase();
                if (app.state.phase === "break") {
                    // Complete the break to get back to work (unless it's the last one)
                    if (i < 2) {
                        app.state.remainingSeconds = 0;
                        app.completePhase();
                    }
                }
            }

            assert(app.state.isLongBreak === true, "Long break triggered after 3 consecutive work sessions");
            assertEqual(app.state.remainingSeconds, 900, "Long break has correct duration (900s)");
            assertEqual(app.state.consecutiveWorkSessions, 0, "Consecutive counter reset after long break trigger");

            // Complete long break and verify history record preserves long-break flag
            app.state.remainingSeconds = 0;
            app.completePhase();
            var lastSession = app.state.sessionHistory[app.state.sessionHistory.length - 1];
            assertEqual(lastSession.phase, "break", "Completed long break recorded as break phase");
            assert(lastSession.isLongBreak === true, "Completed long-break history record has isLongBreak=true");

            // ========================
            // Auto-start next phase
            // ========================
            group("Auto-start next phase");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.stopTimer();
            app.state.autoStartNextPhase = false;
            app.state.phase = "work";
            app.state.remainingSeconds = 0;
            app.completePhase();
            assertEqual(app.state.phase, "break", "completePhase still advances phase when auto-start disabled");
            assertEqual(app.state.isRunning, false, "next phase is paused by default");

            app.stopTimer();
            app.state.autoStartNextPhase = true;
            app.state.phase = "work";
            app.state.remainingSeconds = 0;
            app.completePhase();
            assertEqual(app.state.phase, "break", "completePhase advances phase when auto-start enabled");
            assertEqual(app.state.isRunning, true, "next phase auto-starts when enabled");
            app.stopTimer();

            // ========================
            // getDailySummary / getWeeklySummary
            // ========================
            group("getDailySummary / getWeeklySummary");
            var todayStr = new Date().toISOString().split("T")[0];
            // sessionHistory was populated by completePhase tests above
            var summary = app.getDailySummary(todayStr);
            assert(summary.workCount >= 1, "getDailySummary returns work sessions for today");
            assert(typeof summary.totalFocusMinutes === "number", "getDailySummary returns focus minutes");
            assertEqual(summary.date, todayStr, "getDailySummary has correct date");

            var weekly = app.getWeeklySummary();
            assertEqual(weekly.length, 7, "getWeeklySummary returns 7 days");
            assertEqual(weekly[6].date, todayStr, "getWeeklySummary last day is today");

            // Empty day should return zeros
            var emptySummary = app.getDailySummary("2000-01-01");
            assertEqual(emptySummary.workCount, 0, "getDailySummary empty day has 0 work");
            assertEqual(emptySummary.breakCount, 0, "getDailySummary empty day has 0 break");
            assertEqual(emptySummary.totalFocusMinutes, 0, "getDailySummary empty day has 0 focus min");


            // ========================
            // analytics aggregations
            // ========================
            group("analytics aggregations");
            var sampleHistory = [
                {phase: "work", completed: true, durationSeconds: 1500, startTime: "2026-01-28T09:00:00.000Z"},
                {phase: "work", completed: true, durationSeconds: 3000, startTime: "2026-01-28T13:00:00.000Z"},
                {phase: "break", completed: true, isLongBreak: true, durationSeconds: 900, startTime: "2026-01-28T13:30:00.000Z"},
                {phase: "work", completed: true, durationSeconds: 1500, startTime: "2026-01-29T09:00:00.000Z"},
                {phase: "work", completed: false, durationSeconds: 1500, startTime: "2026-01-29T10:00:00.000Z"},
                {phase: "work", completed: true, durationSeconds: 1500, startTime: "2026-01-30T09:00:00.000Z"},
                {phase: "break", completed: true, isLongBreak: false, durationSeconds: 300, startTime: "2026-01-30T09:30:00.000Z"}
            ];

            var byDay = app.aggregateFocusMinutesByDay(sampleHistory, 3, "2026-01-30T12:00:00.000Z");
            assertEqual(byDay.length, 3, "aggregateFocusMinutesByDay returns requested day count");
            assertEqual(byDay[0].date, "2026-01-28", "aggregateFocusMinutesByDay includes oldest day first");
            assertEqual(byDay[0].minutes, 75, "aggregateFocusMinutesByDay sums focus minutes for day");
            assertEqual(byDay[1].minutes, 25, "aggregateFocusMinutesByDay excludes incomplete sessions");
            assertEqual(byDay[2].minutes, 25, "aggregateFocusMinutesByDay maps most recent day");

            var byHour = app.aggregateSessionsByHour(sampleHistory);
            assertEqual(byHour.length, 24, "aggregateSessionsByHour returns 24 buckets");
            assertEqual(byHour[9].count, 3, "aggregateSessionsByHour counts completed sessions at hour");
            assertEqual(byHour[13].count, 2, "aggregateSessionsByHour counts across phases");
            assertEqual(byHour[10].count, 0, "aggregateSessionsByHour skips incomplete sessions");

            var cadenceStats = app.aggregateLongBreakCadenceStats(sampleHistory);
            assertEqual(cadenceStats.completedLongBreaks, 1, "aggregateLongBreakCadenceStats counts long breaks");
            assertEqual(cadenceStats.averageWorkPerLongBreak, 2, "aggregateLongBreakCadenceStats computes average cycle length");
            assertEqual(cadenceStats.pendingCycleWorkSessions, 2, "aggregateLongBreakCadenceStats counts current cycle progress");

            assertEqual(app.getHeatmapIntensity(0, 60), 0, "getHeatmapIntensity returns 0 for zero minutes");
            assertEqual(app.getHeatmapIntensity(12, 60), 1, "getHeatmapIntensity returns low intensity");
            assertEqual(app.getHeatmapIntensity(20, 60), 2, "getHeatmapIntensity returns medium-low intensity");
            assertEqual(app.getHeatmapIntensity(40, 60), 3, "getHeatmapIntensity returns medium-high intensity");
            assertEqual(app.getHeatmapIntensity(55, 60), 4, "getHeatmapIntensity returns highest intensity");

            // ========================
            // resetCurrentPhase
            // ========================
            group("resetCurrentPhase");
            app.applyPreset("25_5", {resetPhase: true, persist: false});
            app.state.remainingSeconds = 500;
            app.resetCurrentPhase();
            assertEqual(app.state.remainingSeconds, 1500, "resetCurrentPhase restores full duration");
            assertEqual(app.state.isRunning, false, "resetCurrentPhase stops timer");

            // ========================
            // Summary
            // ========================
            var summaryEl = document.createElement("p");
            summaryEl.className = "summary " + (failed === 0 ? "all-pass" : "has-fail");
            summaryEl.textContent = passed + " passed, " + failed + " failed";
            results.appendChild(summaryEl);
        }
    </script>
</body>
</html>
